#include "arkn141_isp_sensor_cfg.h"
#include <stdio.h>
#include <string.h>

#include "xm_proj_define.h"
#include "xm_i2c.h"
#include "arkn141_isp_cmos_sensor_io.h"

#if ARKN141_CMOS_SENSOR == ARKN141_CMOS_SENSOR_JX_H65

// JX-H65 slave ID is programmable, default is 0x60/61 for write and read command
#define	SEN_I2C_ADDR				(0x60 >> 1)
//#define	SEN_I2C_ADDR				(0x6c >> 1)
//#define	SEN_I2C_ADDR				(0x64 >> 1)
//#define	SEN_I2C_ADDR				(0x64 >> 1)


static int I2C_WRITE(unsigned int addr, unsigned int data)
{
	return i2c_reg8_write8(SEN_I2C_ADDR,(addr),(data));	
}

#define	I2C_WRITE_BYTE(addr,data,size)	\
	if(I2C_WRITE((addr), (data)) < 0)	\
		return -1;


typedef struct tagCONFIG_DATA {
	unsigned int	addr;
	unsigned int	data;
} CONFIG_DATA;

//#define		W_1600_H_750	1		// 初始参数
//#define	W_1500_H_800	1
//#define	W_1450_H_825	1
//#define	W_1410_H_850	1
#define	W_1600_H_900	1		// 25fps

static CONFIG_DATA  jx_h65_reg[] = {
	{0x12,    0x40},    	
	{0x0E,    0x10},     
	{0x0F,    0x04},     
	{0x10,    0x1E},   
	{0x11,    0x80},  

	{0x5F,    0x10},  			
	{0x60,    0x10},   
				
	{0x19,    0x64},   
	{0x48,    0x25},  
#if W_1600_H_750	//
	{0x20,    0x20},   
	{0x21,    0x03},   
	{0x22,    0xEE},   
	{0x23,    0x02}, 
#elif W_1500_H_800
	{0x20,    0xEE},   
	{0x21,    0x02},   
	{0x22,    0x20},   
	{0x23,    0x03}, 
#elif W_1450_H_825
	{0x20,    0xD5},   
	{0x21,    0x02},   
	{0x22,    0x39},   
	{0x23,    0x03}, 
#elif W_1410_H_850
	{0x20,    0xC1},   
	{0x21,    0x02},   
	{0x22,    0x52},   
	{0x23,    0x03}, 
#elif W_1600_H_900
	{0x20,    0x20},   
	{0x21,    0x03},   
	{0x22,    0x84},   
	{0x23,    0x03}, 	
#endif
	{0x24,    0x80},
	//{0x24,    0x84},
	{0x25,    0xD0},
	{0x26,    0x22},
	{0x27,    0x5C - 8},		// 修改窗口起始位置(左移8个像素点)
	{0x28,    0x18},
	{0x29,    0x01},
	{0x2A,    0x48},
	{0x2B,    0x25},
	{0x2C,    0x00},
	{0x2D,    0x00},
	{0x2E,    0xBB},
	{0x2F,    0x40},
	{0x41,    0x90},
	{0x42,    0x12},
	{0x39,    0x90},
	{0x1D,    0xFF},
	//{0x1E,    0x1F},
	//{0x1E,    0x1F | (1 << 5) | (1 << 7)},	// 
	{0x1E,    0x1F | (1 << 7) | (1 << 5)},
	{0x6C,    0x80},
	{0x1F,    0x10},
	{0x31,    0x0C},
	{0x32,    0x20},
	{0x33,    0x0C},
	{0x34,    0x4F},
	{0x36,    0x06},
	{0x38,    0x39},
	{0x3A,    0x08},
	{0x3B,    0x50},
	{0x3C,    0xA0},
	{0x3D,    0x00},
	{0x3E,    0x01},
	{0x3F,    0x00},
	{0x40,    0x00},
	{0x0D,    0x50},
	{0x5A,    0x43},
	{0x5B,    0xB3},
	{0x5C,    0x0C},
	{0x5D,    0x7E},
	{0x5E,    0x24},
	{0x62,    0x40},
	{0x67,    0x48},
	{0x6A,    0x11},
	{0x68,    0x04},
	{0x8F,    0x9F},
	{0x0C,    0x00},
	{0x59,    0x97},
	{0x4A,    0x05},
	{0x50,    0x03},
	{0x47,    0x62},
	{0x7E,    0xCD},
	{0x8D,    0x87},
	{0x49,    0x10},
	{0x7F,    0x52},
	{0x8E,    0x00},
	{0x8C,    0xFF},
	{0x8B,    0x01},
	{0x57,    0x02},
	{0x94,    0x00},
	{0x95,    0x00},
	{0x63,    0x80},
	{0x7B,    0x46},
	{0x7C,    0x2D},
	{0x90,    0x00},
	{0x79,    0x00},
	{0x13,    0x81},
	{0x12,    0x00},
	{0x45,    0x89},
	{0x93,    0x68}
} ;

int jx_h65_init (void)
{
	int i;
	int ret;
	
	// read id
	unsigned int PIDH, PIDL;
	PIDH = 0;
	PIDL = 0;
	ret = -1;
	i2c_reg8_read8 (SEN_I2C_ADDR, 0x0A, &PIDH);
	i2c_reg8_read8 (SEN_I2C_ADDR, 0x0B, &PIDL);
	XM_printf ("PIDH=%02x, PIDL=%02x\n", PIDH, PIDL);
	if(PIDH == 0x0A && PIDL == 0x65 || PIDH == 0x00 && PIDL == 0x65)
	{
		ret = 0;
		XM_printf ("Found jx_h65\n");
	}
	else
	{
		XM_printf ("Miss  jx_h65\n");
	//	return -1;
	}
	
	
	
	for (i = 0; i < sizeof(jx_h65_reg)/sizeof(jx_h65_reg[0]); i ++)
	{
		if(I2C_WRITE(jx_h65_reg[i].addr, jx_h65_reg[i].data) < 0)
			return -1;
	}

	OS_Delay (1);

	if(I2C_WRITE (0x45, 0x19) < 0)
		return -1;
	
	if(I2C_WRITE (0x1F, 0x11) < 0)
		return -1;
	
#if 1  //解决从视频回放列表返回到录像时闪的问题
	I2C_WRITE (0x00, 0x00);
	I2C_WRITE (0x01, 0x00);
	I2C_WRITE (0x02, 0x00);
#endif

	return 0;
}

#endif	// #if ARKN141_CMOS_SENSOR == ARKN141_CMOS_SENSOR_GC0308
