// BG0806

#include <stdio.h>
#include <string.h>
#include "xm_i2c.h"
#include "arkn141_isp_sensor_cfg.h"
#include "arkn141_isp_cmos_sensor_io.h"



#define	SEN_I2C_ADDR				(0x64 >> 1)
static void I2C_WRITE (unsigned int addr, unsigned int data)
{
	i2c_reg16_write8(SEN_I2C_ADDR,(addr),(data));	
}

static unsigned int I2C_READ (unsigned int addr)
{
	unsigned int data = 0;
	i2c_reg16_read8 (SEN_I2C_ADDR,(addr), &data);
	return data;
}

typedef struct stSensor_cfg_E2 {
	unsigned int  addr;
	unsigned char data;
} BG0806;

#define	EXTERNAL_LDO_1V5
//如需使用外部1.5V LDO,需定义EXTERNAL_LDO_1V5宏
struct stSensor_cfg_E2 Sensor_Cfg_1080P30FPS[] =
{
#if 1
	 // 20161228
    0x0200, 0x01,
    0x0003, 0x27, //hstart
    0x00fa, 0x8f,
    0x000e, 0x0A, //0806_4times_74.25M_30fps
    0x000f, 0x50, //row time F_W=2200
    0x0013, 0x01,
    0x0022, 0x25, //vblank
    0x0029, 0x30, 
    0x002b, 0x30, 
    0x0031, 0xd0, //rstb2rmp1 gap
    0x0035, 0xd0, //tx2rmp2 gap
    0x003c, 0x01, 
    0x003d, 0x80, //rmp1_w@pclk domain
    0x003e, 0x04, //ncp
    0x0042, 0x01,
    0x005c, 0x00, //lsh_io ctrlbit for 1.8 VDDIO
//  0x005c, 0x05, //lsh_io ctrlbit for 2.8~3.3 VDDIO
    0x0061, 0x04, 
    0x0062, 0x50, //rmp2_w@pclk domain 
    0x0064, 0x00, //rmp1_w@rmpclk domain
    0x0065, 0x80, //rmp1_w@rmpclk domain
    0x0067, 0x01, //rmp2_w@rmpclk domain
    0x0068, 0x90, //rmp2_w@rmpclk domain
    0x006c, 0x03, //pd mipi dphy&dphy ldo
    0x007f, 0x03,
    0x0080, 0x01, //dot en enable
    0x0081, 0x00,
    0x0082, 0x0b,
    0x0084, 0x08,
    0x0088, 0x05, //pclk dly
    0x008e, 0x00,
    0x008f, 0x00,
    0x0094, 0x01, //rmp div1
    0x0095, 0x01, //rmp div4
    0x009e, 0x03, //4 times
    0x009f, 0x20, //rmp2gap@rmpclk
    0x00b1, 0x7f, 
    0x00b2, 0x02, 
    0x00bc, 0x02, 
    0x00bd, 0x00, 
    0x0120, 0x01, //blc on 01, direct
    0x0139, 0x07,
    0x0139, 0xff,
    0x013b, 0x08,
    0x01a5, 0x07, //row noise on 07
#ifdef EXTERNAL_LDO_1V5 //??sensor 1.5V(VDD)?????????????????
    0x0132, 0x00, //k
    0x0133, 0xff,
    0x0206, 0x03,
    0x0207, 0x01,
    0x006e, 0x00,
#else
    0x0132, 0x01, //k
    0x0133, 0x30,
    0x0206, 0x03,
    0x0207, 0xb7,
    0x006e, 0x01,
#endif
    0x0061, 0x04,
    0x002b, 0x30,
    0x0030, 0x00,
    0x0034, 0x00,
    0x004d, 0x00,
    0x004f, 0x09,
    0x0067, 0x01,
    0x0068, 0x90,

    0x001d, 0x01,
	
//	0x008d, 0xFF
		 
		 
#else
			
			
		0x0200, 0x01, 
		0x0003, 0x27,  
		0x00fa, 0x8f,
		0x000e, 0x08, //0806_4times_74.25M_30fps
		0x000f, 0x98, //row time F_W=2200
		0x0013, 0x01,  
		0x0022, 0x25, //vblank
		0x0029, 0x30, 
		0x002b, 0x30, 
		0x0031, 0xd0, //rstb2rmp1 gap
		0x0035, 0xd0, //tx2rmp2 gap
		0x003c, 0x01, 
		0x003d, 0x80, //rmp1_w@pclk domain
		0x003e, 0x05, //ncp
		0x0042, 0x01, 
		0x005c, 0x00, //lsh_io ctrlbit for 1.8VDDIO
		0x0061, 0x04, 
		0x0062, 0x50, //rmp2_w@pclk domain 
		0x0065, 0x80, //rmp1_w@rmpclk domain
		0x0068, 0x90, //rmp2_w@rmpclk domain
		0x006c, 0x03, //pd mipi dphy&dphy ldo
		0x007f, 0x03, 
		0x0080, 0x01,  //dot en disable  hxb20161116
		0x0081, 0x00, 
		0x0082, 0x0b,
		0x0084, 0x08, //hxb20161116
		0x0088, 0x05, //pclk dly
		0x008e, 0x00, 
		0x008f, 0x00, 
		0x0094, 0x01, //rmp div1
		0x0095, 0x01, //rmp div4
		0x009e, 0x03, //4 times
		0x009f, 0x20, //rmp2gap@rmpclk
		0x00b1, 0x7f, 
		0x00b2, 0x02, 
		0x00bc, 0x02, 
		0x00bd, 0x00, 
		0x0120, 0x01, //blc on 01 direct
		0x0139, 0x07, 
		0x0139, 0xff, 
		0x013b, 0x08, 
		0x01a5, 0x07, //row noise on 07
		#ifdef EXTERNAL_LDO_1V5
		0x0132, 0x00, //k
		0x0133, 0xff,
		0x0206, 0x03,
		0x0207, 0x01,
		0x006e, 0x00,
		#else
		0x0132, 0x01, //k
		0x0133, 0x30,
		0x0206, 0x03,
		0x0207, 0xb7,
		0x006e, 0x01,
		#endif
		0x001d, 0x01,
		
		0x008d, 0xFF
			
			
#endif		
			
			
};





// 1080P模式 12bit
int bg0806_init_12bit  (unsigned int frame_lines)
{
	int i;
	printf ("cmos sensor bg0806 init 1080P 12bit mode\n");
	
	for(i = 0; i < sizeof(Sensor_Cfg_1080P30FPS)/sizeof(Sensor_Cfg_1080P30FPS[0]); i ++)
	{
		I2C_WRITE (Sensor_Cfg_1080P30FPS[i].addr, Sensor_Cfg_1080P30FPS[i].data);
	}

	return 0;
}
